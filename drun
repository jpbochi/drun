#!/usr/bin/env sh
set -o errexit
set -o nounset
set -o noglob

short_usage() {
  echo >&2 'Usage: drun [options] (image|-I image) [--] [command]'
  echo >&2 'See `drun -?` for help.'
  exit 1
}
usage() {
  echo >&2 'Usage: drun [options] (image|-I image) [--] [command]'
  echo >&2 '  -?                        Shows this help'
  echo >&2 '  -K                        Keep container after run (i.e. does not user docker run --rm option)'
  echo >&2 '  -x                        Enables bash xtrace so that exact `docker run` command is displayed'
  echo >&2 '  -N                        Uses node:AUTO image, where AUTO is detected from a local package.json if any (also mounts .npmrc, if present)'
  echo >&2 '  -M ALT_IMAGE              Prefers node ALT_IMAGE (can be either alpine, wheezy or slim) (e.g., with -NM slim, will resolve to node:AUTO-slim)'
  echo >&2 '  -A                        Prefers mhart/alpine-node-auto images (e.g., with -NA, will resolve to mhart/alpine-node-auto:AUTO)'
  echo >&2 '  -P                        Mounts your ~/.npm/ into the container (Only useful with node, obviously)'
  echo >&2 '  -E ENV_REGEX              Forwards local env variables whose names match ENV_REGEX to container'
  echo >&2 '  -I image                  Tells which docker image to use, allowing other options to set later'
  echo >&2 '  -D                        Do not mount /var/run/docker.sock into the container'
  echo >&2 '  -X SOME_DOCKER_OPTION     Passes option directly to docker (e.g. `drun -X --dns=8.8.8.8` results in `docker run --dns=8.8.8.8 ...`)'
  echo >&2 '  -a|c|e|h|l|m|p|u|v|w VAL  Work exactly like `docker run` options (e.g. `drun -e FOO=bar` results in `docker run -e FOO=bar ...`)'
  exit 0
}

node_version_jq() {
  jq -r -e '.engines.node // "latest"' package.json
}
node_version_python() {
  python -c "import json;print json.load(open('package.json')).get('engines',{}).get('node','latest')"
}
node_version_ruby() {
  cat package.json | ruby -e 'require "json"; puts JSON[STDIN.read].fetch("engine",{}).fetch("node","latest")'
}
node_version() {
  if [ ! -f package.json ]; then
    echo 'latest'
  else
    node_version_jq 2> /dev/null || \
    node_version_python 2> /dev/null || \
    node_version_ruby 2> /dev/null || \
    (echo >&2 'drun ERR! Failed to resolve node version. Defaulting to "latest"' && echo 'latest')
  fi
}

CURRENT_DIR=$(pwd)
CONTAINER_HOME=$CURRENT_DIR
while getopts ':a:c:e:h:l:m:p:u:v:w:X:E:I:KNM:APxD' OPT; do
  case $OPT in
    a|c|e|h|l|m|p|u|v|w)
      EXTRA_OPTS="${EXTRA_OPTS:-} -${OPT} ${OPTARG}";;
    X)
      EXTRA_OPTS="${EXTRA_OPTS:-} ${OPTARG}";;
    E)
      ENV_REGEX="$OPTARG";;
    I)
      IMAGE="$OPTARG";;
    K)
      RM_OPT="";;
    N)
      IMAGE="node:$(node_version)"
      if [ -r "$HOME/.npmrc" ]; then
        EXTRA_OPTS="${EXTRA_OPTS:-} -v $HOME/.npmrc:/usr/etc/npmrc:ro -v $HOME/.npmrc:/usr/local/etc/npmrc:ro"
      fi
      ;;
    M)
      NODE_ALT_IMAGE="$OPTARG";;
    A)
      PREFER_ALPINE="y";;
    P)
      EXTRA_OPTS="${EXTRA_OPTS:-} -v $CONTAINER_HOME/.npm/_git-remotes"
      EXTRA_OPTS="${EXTRA_OPTS:-} -v $HOME/.npm:$CONTAINER_HOME/.npm"
      ;;
    x)
      XTRACE="y";;
    D)
      MOUNTDOCKERSOCK="n";;
    \?)
      if [ "$OPTARG" = '?' ]; then
        usage
      fi
      echo >&2 "Unknown option -$OPTARG"
      short_usage;;
    :)
      echo >&2 "Missing argument for option -$OPTARG"
      short_usage;;
  esac
done
shift $((OPTIND-1))

if [ -z "${IMAGE:-}" ]; then
  IMAGE="${1:-}"
  [ -z "$IMAGE" ] && usage
  shift
fi
if [ "${PREFER_ALPINE:-}" = 'y' ]; then
  IMAGE=$(echo "$IMAGE" | sed 's/^node\([:]*\)/mhart\/alpine-node-auto\1/')
elif [ -n "${NODE_ALT_IMAGE:-}" ]; then
  IMAGE=$(echo "$IMAGE" \
    | sed 's/^node:\([0-9.]*\)$/node:\1-'"${NODE_ALT_IMAGE}"'/' \
    | sed 's/^node:latest$/node:'"${NODE_ALT_IMAGE}"'/' \
    | sed 's/^node$/node:'"${NODE_ALT_IMAGE}"'/')
fi

if [ -n "${ENV_REGEX:-}" ]; then
  ENV_FILE=$(echo ".local-env-$$")
  env | grep '=' | awk -F '=' '{if($1 ~ /'"$ENV_REGEX"'/) print}' > $ENV_FILE
  trap "rm -f $ENV_FILE" EXIT
  ENV_FILE_OPT="--env-file=$ENV_FILE"
fi

MAP_CURRENT_DIR_OPT="-v $CURRENT_DIR:$CONTAINER_HOME"
# Inception detection
if [ -f '/proc/1/cgroup' ]; then
  CURRENT_CONTAINER=$(grep '/docker/' -- /proc/1/cgroup | head -n1 | cut -d '/' -f 3)
  if [ -n "${CURRENT_CONTAINER}" ] && docker inspect --format='ok' "${CURRENT_CONTAINER}" 2>&1 > /dev/null; then
    # Maps volumes from current container
    EXTRA_OPTS="${EXTRA_OPTS:-} --volumes-from $CURRENT_CONTAINER"

    # If current directory is inside any of the mounts of the current container
    MOUNTS=$(docker inspect --format='{{range .Mounts}} -e '{{.Destination}}'{{end}}' "${CURRENT_CONTAINER}")
    if [ "0" != $(echo "${CURRENT_DIR}" | grep ${MOUNTS}) ]; then
      MAP_CURRENT_DIR_OPT=''
    fi
  fi
fi

DSOCK=/var/run/docker.sock
if [ "${MOUNTDOCKERSOCK:-}" != 'n' -a -r "$DSOCK" -a -w "$DSOCK" -a -S "$DSOCK" ]; then
  if curl --help | grep -q unix-socket && curl -sS --unix-socket "$DSOCK" http://docker/_ping | grep -q OK; then
    EXTRA_OPTS="${EXTRA_OPTS:-} -v ${DSOCK}:${DSOCK}"
  elif nc -h 2>&1 | grep -qe '-X\b' && printf 'GET /_ping HTTP/1.1\nHost: daemon\n\n' | nc -U "$DSOCK" | head -n 1 | grep -q '200 OK'; then
    EXTRA_OPTS="${EXTRA_OPTS:-} -v ${DSOCK}:${DSOCK}"
  fi
elif [ -n "${DOCKER_HOST}" ]; then
  EXTRA_OPTS="${EXTRA_OPTS:-} -e DOCKER_HOST=${DOCKER_HOST}"
  EXTRA_OPTS="${EXTRA_OPTS:-} -e DOCKER_TLS_VERIFY=${DOCKER_TLS_VERIFY}"
  EXTRA_OPTS="${EXTRA_OPTS:-} -e DOCKER_CERT_PATH=${DOCKER_CERT_PATH} -v ${DOCKER_CERT_PATH}:${DOCKER_CERT_PATH}:ro"
fi

RM_OPT=${RM_OPT=--rm}

# Enables interactive TTY if available
TTY_OPT="-i"
[ -t 0 ] && TTY_OPT="-it"

[ "${XTRACE:-}" = 'y' ] && set -o xtrace
docker run $RM_OPT $TTY_OPT \
  $MAP_CURRENT_DIR_OPT \
  -e HOME=$CONTAINER_HOME -w $CONTAINER_HOME \
  --net=host \
  ${ENV_FILE_OPT:-} ${EXTRA_OPTS:-} \
  $IMAGE "$@"
